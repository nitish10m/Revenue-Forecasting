# -*- coding: utf-8 -*-
"""ARIMAmethod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11WyQus6AeIjggYDcz-ry6H6MZcWo0UTM
"""

import pandas as pd
import numpy as np

df_rev = pd.read_csv("/content/drive/My Drive/Revenue Forecast Project/Data/Revenue_original.csv")

#df_rev.head(5)

from google.colab import drive
drive.mount('/content/drive')

"""Data cleaning steps"""

# Create Report date from raw data

conditions =[(df_rev['Quarter'].str.split(' ').str[1] =="Q1"),\
             (df_rev['Quarter'].str.split(' ').str[1] =="Q2"),\
             (df_rev['Quarter'].str.split(' ').str[1] =="Q3"),\
             (df_rev['Quarter'].str.split(' ').str[1] =="Q4")\
            ]

choices =[("31-03-" + df_rev['Quarter'].str.split(' ').str[0]),\
          ("30-06-" + df_rev['Quarter'].str.split(' ').str[0]),\
          ("30-09-" + df_rev['Quarter'].str.split(' ').str[0]),\
          ("31-12-" + df_rev['Quarter'].str.split(' ').str[0])\
         ]


df_rev['ReportDate'] = np.select(conditions, choices, default="NA")

df_rev.head(5)

#Convert Revernue to float type
df_rev['Revenue'] = df_rev['Revenue'].str.replace(',','')
df_rev['Revenue'] = df_rev['Revenue'].astype('float')

# Convert ReportDate to date type

df_rev['ReportDate'] = pd.to_datetime(df_rev['ReportDate'])

# remove unwanted column
df_rev.drop(['Quarter'], axis=1, inplace=True)

# sort the dataframe in acceding 
df_rev = df_rev.sort_values(['ReportDate'], ascending=[True])

# set column ReportDate as index of dataframe
df_rev.set_index('ReportDate', inplace=True)

# set column 'ReportDate' as Index of dataframe 
df_rev.head(5)

"""# ARIMA Model fitting steps"""

# ARIMA Models
# ARIMA stands for AutoRegressive Integrated Moving Average, is a forecasting algorithm 
# based on the idea that the information in the past values of the time series can alone be used to predict the future values.
# The forecasters depend on the parameters (p,d,q) of the ARIMA model
# p is the order of the AR term.  It refers to the number of lags of Y to be used as predictors.

# q is the order of the MA term. It refers to the number of lagged forecast errors that should go into the ARIMA Model.

# d is the number of differencing required to make the time series stationary. The most common approach to make the series 
# stationary is to difference it. That is, subtract the previous value from the current value.
# The value of d, therefore, is the minimum number of differencing needed to make the series stationary.
# If the time series is already stationary, then d = 0.

from statsmodels.tsa.arima_model import ARIMA

from matplotlib import pyplot
from sklearn.metrics import mean_squared_error

#  fit an ARIMA(5,1,0) model. 
#  sets the lag value to 5 for autoregression 
#  uses a difference order of 1 to make the time series stationary 
#  uses a moving average model of 0

# The model can be tuned with other values for parameters  p, d, and q

X = df_rev.values
size = int(len(X) * 0.75)
train, test = X[0:size], X[size:len(X)]
history = [x for x in train]
predictions = list()
for t in range(len(test)):
    model = ARIMA(history, order=(5,1,0))
    model_fit = model.fit(disp=0)
    output = model_fit.forecast()
    yhat = output[0]
    predictions.append(yhat)
    obs = test[t]
    history.append(obs)
    print('predicted=%f, expected=%f' % (yhat, obs))
error = np.sqrt(mean_squared_error(test, predictions))
print('Test Root MSE: %.3f' % error)
# plot
pyplot.plot(test)
#red color line for Predictions
pyplot.plot(predictions, color='red')
pyplot.show()

"""Conclusion:

In the above plot red color is prediction 

Clearly there is no seasonality in revenue 
Revenue is simply upward trend except few downturns 
"""

#Summary Statistics 

from pandas import DataFrame

print(model_fit.summary())
# plot residual errors
residuals = DataFrame(model_fit.resid)
residuals.plot()
pyplot.show()
residuals.plot(kind='kde')
pyplot.show()
print(residuals.describe())

"""Plot as well as  summary statistics concludes that there is absense of seasonality, and autoregression elements but there is a presence of trends therefore model parameter calibration for amount of differencing and the size of the lag is not quite useful"""

